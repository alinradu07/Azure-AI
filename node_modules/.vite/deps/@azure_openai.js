import "./chunk-LQ2VYIYD.js";

// node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js
var AzureKeyCredential = class {
  /**
   * The value of the key to be used in authentication
   */
  get key() {
    return this._key;
  }
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  update(newKey) {
    this._key = newKey;
  }
};

// node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
var listenersMap = /* @__PURE__ */ new WeakMap();
var abortedMap = /* @__PURE__ */ new WeakMap();
var AbortSignal = class _AbortSignal {
  constructor() {
    this.onabort = null;
    listenersMap.set(this, []);
    abortedMap.set(this, false);
  }
  /**
   * Status of whether aborted or not.
   *
   * @readonly
   */
  get aborted() {
    if (!abortedMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    return abortedMap.get(this);
  }
  /**
   * Creates a new AbortSignal instance that will never be aborted.
   *
   * @readonly
   */
  static get none() {
    return new _AbortSignal();
  }
  /**
   * Added new "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be added
   */
  addEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    listeners.push(listener);
  }
  /**
   * Remove "abort" event listener, only support "abort" event.
   *
   * @param _type - Only support "abort" event
   * @param listener - The listener to be removed
   */
  removeEventListener(_type, listener) {
    if (!listenersMap.has(this)) {
      throw new TypeError("Expected `this` to be an instance of AbortSignal.");
    }
    const listeners = listenersMap.get(this);
    const index = listeners.indexOf(listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
  /**
   * Dispatches a synthetic event to the AbortSignal.
   */
  dispatchEvent(_event) {
    throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
  }
};
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}

// node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
};
var AbortController2 = class {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(parentSignals) {
    this._signal = new AbortSignal();
    if (!parentSignals) {
      return;
    }
    if (!Array.isArray(parentSignals)) {
      parentSignals = arguments;
    }
    for (const parentSignal of parentSignals) {
      if (parentSignal.aborted) {
        this.abort();
      } else {
        parentSignal.addEventListener("abort", () => {
          this.abort();
        });
      }
    }
  }
  /**
   * The AbortSignal associated with this controller that will signal aborted
   * when the abort method is called on this controller.
   *
   * @readonly
   */
  get signal() {
    return this._signal;
  }
  /**
   * Signal that any operations passed this controller's associated abort signal
   * to cancel any remaining work and throw an `AbortError`.
   */
  abort() {
    abortSignal(this._signal);
  }
  /**
   * Creates a new AbortSignal instance that will abort after the provided ms.
   * @param ms - Elapsed time in milliseconds to trigger an abort.
   */
  static timeout(ms) {
    const signal = new AbortSignal();
    const timer = setTimeout(abortSignal, ms, signal);
    if (typeof timer.unref === "function") {
      timer.unref();
    }
    return signal;
  }
};

// node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return new Promise((resolve, reject) => {
    function rejectOnAbort() {
      reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x) => {
        removeListeners();
        resolve(x);
      }, (x) => {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.addEventListener("abort", onAbort);
  });
}

// node_modules/@azure/core-util/dist-esm/src/delay.js
var StandardAbortMessage = "The delay was aborted.";
function delay(timeInMs, options) {
  let token;
  const { abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return createAbortablePromise((resolve) => {
    token = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token),
    abortSignal: abortSignal2,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
  });
}

// node_modules/@azure/core-util/dist-esm/src/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}

// node_modules/@azure/core-util/dist-esm/src/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}

// node_modules/@azure/core-util/dist-esm/src/error.js
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}

// node_modules/@azure/core-util/dist-esm/src/bytesEncoding.browser.js
var hexDigits = new Set("0123456789abcdefABCDEF");

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js
function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const randomNumber = Math.floor(Math.random() * 16);
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += randomNumber & 3 | 8;
    } else {
      uuid += randomNumber.toString(16);
    }
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js
var _a;
var uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : generateUUID;
function randomUUID() {
  return uuidFunction();
}

// node_modules/@azure/core-util/dist-esm/src/checkEnvironment.js
var _a2;
var _b;
var _c;
var _d;
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a2 = self.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
var isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_d = process.versions) === null || _d === void 0 ? void 0 : _d.node) && // Deno thought it was a good idea to spoof process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
!isDeno;
var isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
var isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";

// node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}

// node_modules/@azure/openai/dist-esm/src/OpenAIKeyCredential.js
var OpenAIKeyCredential = class {
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = createKey(key);
  }
  /**
   * The value of the key to be used in authentication
   */
  get key() {
    return this._key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  update(newKey) {
    this._key = createKey(newKey);
  }
};
function createKey(key) {
  return key.startsWith("Bearer ") ? key : `Bearer ${key}`;
}

// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js
var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
var HttpPipeline = class _HttpPipeline {
  constructor(policies) {
    var _a3;
    this._policies = [];
    this._policies = (_a3 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a3 !== void 0 ? _a3 : [];
    this._orderedPolicies = void 0;
  }
  addPolicy(policy, options = {}) {
    if (options.phase && options.afterPhase) {
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    }
    if (options.phase && !ValidPhaseNames.has(options.phase)) {
      throw new Error(`Invalid phase name: ${options.phase}`);
    }
    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
    }
    this._policies.push({
      policy,
      options
    });
    this._orderedPolicies = void 0;
  }
  removePolicy(options) {
    const removedPolicies = [];
    this._policies = this._policies.filter((policyDescriptor) => {
      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
        removedPolicies.push(policyDescriptor.policy);
        return false;
      } else {
        return true;
      }
    });
    this._orderedPolicies = void 0;
    return removedPolicies;
  }
  sendRequest(httpClient, request) {
    const policies = this.getOrderedPolicies();
    const pipeline = policies.reduceRight((next, policy) => {
      return (req) => {
        return policy.sendRequest(req, next);
      };
    }, (req) => httpClient.sendRequest(req));
    return pipeline(request);
  }
  getOrderedPolicies() {
    if (!this._orderedPolicies) {
      this._orderedPolicies = this.orderPolicies();
    }
    return this._orderedPolicies;
  }
  clone() {
    return new _HttpPipeline(this._policies);
  }
  static create() {
    return new _HttpPipeline();
  }
  orderPolicies() {
    const result = [];
    const policyMap = /* @__PURE__ */ new Map();
    function createPhase(name) {
      return {
        name,
        policies: /* @__PURE__ */ new Set(),
        hasRun: false,
        hasAfterPolicies: false
      };
    }
    const serializePhase = createPhase("Serialize");
    const noPhase = createPhase("None");
    const deserializePhase = createPhase("Deserialize");
    const retryPhase = createPhase("Retry");
    const signPhase = createPhase("Sign");
    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
    function getPhase(phase) {
      if (phase === "Retry") {
        return retryPhase;
      } else if (phase === "Serialize") {
        return serializePhase;
      } else if (phase === "Deserialize") {
        return deserializePhase;
      } else if (phase === "Sign") {
        return signPhase;
      } else {
        return noPhase;
      }
    }
    for (const descriptor of this._policies) {
      const policy = descriptor.policy;
      const options = descriptor.options;
      const policyName = policy.name;
      if (policyMap.has(policyName)) {
        throw new Error("Duplicate policy names not allowed in pipeline");
      }
      const node = {
        policy,
        dependsOn: /* @__PURE__ */ new Set(),
        dependants: /* @__PURE__ */ new Set()
      };
      if (options.afterPhase) {
        node.afterPhase = getPhase(options.afterPhase);
        node.afterPhase.hasAfterPolicies = true;
      }
      policyMap.set(policyName, node);
      const phase = getPhase(options.phase);
      phase.policies.add(node);
    }
    for (const descriptor of this._policies) {
      const { policy, options } = descriptor;
      const policyName = policy.name;
      const node = policyMap.get(policyName);
      if (!node) {
        throw new Error(`Missing node for policy ${policyName}`);
      }
      if (options.afterPolicies) {
        for (const afterPolicyName of options.afterPolicies) {
          const afterNode = policyMap.get(afterPolicyName);
          if (afterNode) {
            node.dependsOn.add(afterNode);
            afterNode.dependants.add(node);
          }
        }
      }
      if (options.beforePolicies) {
        for (const beforePolicyName of options.beforePolicies) {
          const beforeNode = policyMap.get(beforePolicyName);
          if (beforeNode) {
            beforeNode.dependsOn.add(node);
            node.dependants.add(beforeNode);
          }
        }
      }
    }
    function walkPhase(phase) {
      phase.hasRun = true;
      for (const node of phase.policies) {
        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
          continue;
        }
        if (node.dependsOn.size === 0) {
          result.push(node.policy);
          for (const dependant of node.dependants) {
            dependant.dependsOn.delete(node);
          }
          policyMap.delete(node.policy.name);
          phase.policies.delete(node);
        }
      }
    }
    function walkPhases() {
      for (const phase of orderedPhases) {
        walkPhase(phase);
        if (phase.policies.size > 0 && phase !== noPhase) {
          if (!noPhase.hasRun) {
            walkPhase(noPhase);
          }
          return;
        }
        if (phase.hasAfterPolicies) {
          walkPhase(noPhase);
        }
      }
    }
    let iteration = 0;
    while (policyMap.size > 0) {
      iteration++;
      const initialResultLength = result.length;
      walkPhases();
      if (result.length <= initialResultLength && iteration > 1) {
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
      }
    }
    return result;
  }
};
function createEmptyPipeline() {
  return HttpPipeline.create();
}

// node_modules/@azure/logger/dist-esm/src/log.browser.js
function log(...args) {
  if (args.length > 0) {
    const firstArg = String(args[0]);
    if (firstArg.includes(":error")) {
      console.error(...args);
    } else if (firstArg.includes(":warning")) {
      console.warn(...args);
    } else if (firstArg.includes(":info")) {
      console.info(...args);
    } else if (firstArg.includes(":verbose")) {
      console.debug(...args);
    } else {
      console.debug(...args);
    }
  }
}

// node_modules/@azure/logger/dist-esm/src/debug.js
var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];
if (debugEnvVariable) {
  enable(debugEnvVariable);
}
var debugObj = Object.assign((namespace) => {
  return createDebugger(namespace);
}, {
  enable,
  enabled,
  disable,
  log
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debug_default = debugObj;

// node_modules/@azure/logger/dist-esm/src/index.js
var registeredLoggers = /* @__PURE__ */ new Set();
var logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
var azureLogLevel;
var AzureLogger = debug_default("azure");
AzureLogger.log = (...args) => {
  debug_default.log(...args);
};
var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
if (logLevelFromEnv) {
  if (isAzureLogLevel(logLevelFromEnv)) {
    setLogLevel(logLevelFromEnv);
  } else {
    console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
  }
}
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger4 of registeredLoggers) {
    if (shouldEnable(logger4)) {
      enabledNamespaces2.push(logger4.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger4 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger4);
  if (shouldEnable(logger4)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger4.namespace);
  }
  registeredLoggers.add(logger4);
  return logger4;
}
function shouldEnable(logger4) {
  return Boolean(azureLogLevel && levelMap[logger4.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js
var logger = createClientLogger("core-rest-pipeline");

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
];
var defaultAllowedQueryParameters = ["api-version"];
var Sanitizer = class {
  constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
  }
  sanitize(obj) {
    const seen = /* @__PURE__ */ new Set();
    return JSON.stringify(obj, (key, value) => {
      if (value instanceof Error) {
        return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
      }
      if (key === "headers") {
        return this.sanitizeHeaders(value);
      } else if (key === "url") {
        return this.sanitizeUrl(value);
      } else if (key === "query") {
        return this.sanitizeQuery(value);
      } else if (key === "body") {
        return void 0;
      } else if (key === "response") {
        return void 0;
      } else if (key === "operationSpec") {
        return void 0;
      } else if (Array.isArray(value) || isObject(value)) {
        if (seen.has(value)) {
          return "[Circular]";
        }
        seen.add(value);
      }
      return value;
    }, 2);
  }
  sanitizeHeaders(obj) {
    const sanitized = {};
    for (const key of Object.keys(obj)) {
      if (this.allowedHeaderNames.has(key.toLowerCase())) {
        sanitized[key] = obj[key];
      } else {
        sanitized[key] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeQuery(value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const sanitized = {};
    for (const k of Object.keys(value)) {
      if (this.allowedQueryParameters.has(k.toLowerCase())) {
        sanitized[k] = value[k];
      } else {
        sanitized[k] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeUrl(value) {
    if (typeof value !== "string" || value === null) {
      return value;
    }
    const url = new URL(value);
    if (!url.search) {
      return value;
    }
    for (const [key] of url.searchParams) {
      if (!this.allowedQueryParameters.has(key.toLowerCase())) {
        url.searchParams.set(key, RedactedString);
      }
    }
    return url.toString();
  }
};

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js
var logPolicyName = "logPolicy";
function logPolicy(options = {}) {
  var _a3;
  const logger4 = (_a3 = options.logger) !== null && _a3 !== void 0 ? _a3 : logger.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request, next) {
      if (!logger4.enabled) {
        return next(request);
      }
      logger4(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      logger4(`Response status code: ${response.status}`);
      logger4(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js
var redirectPolicyName = "redirectPolicy";
var allowedRedirect = ["GET", "HEAD"];
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request.url);
    request.url = url.toString();
    if (status === 303) {
      request.method = "GET";
      request.headers.delete("Content-Length");
      delete request.body;
    }
    request.headers.delete("Authorization");
    const res = await next(request);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js
function getHeaderName() {
  return "x-ms-useragent";
}
function setPlatformSpecificData(map) {
  var _a3, _b2, _c2;
  const localNavigator = globalThis.navigator;
  map.set("OS", ((_c2 = (_b2 = (_a3 = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a3 === void 0 ? void 0 : _a3.platform) !== null && _b2 !== void 0 ? _b2 : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c2 !== void 0 ? _c2 : "unknown").replace(" ", ""));
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js
var SDK_VERSION = "1.12.2";
var DEFAULT_RETRY_POLICY_COUNT = 3;

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
  setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js
var UserAgentHeaderName = getUserAgentHeaderName();
var userAgentPolicyName = "userAgentPolicy";
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(UserAgentHeaderName)) {
        request.headers.set(UserAgentHeaderName, userAgentValue);
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js
function decompressResponsePolicy() {
  throw new Error("decompressResponsePolicy is not supported in browser environment");
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js
var StandardAbortMessage2 = "The operation was aborted.";
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage2));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js
var RetryAfterHeader = "Retry-After";
var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (e) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js
var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
function exponentialRetryStrategy(options = {}) {
  var _a3, _b2;
  const retryInterval = (_a3 = options.retryDelayInMs) !== null && _a3 !== void 0 ? _a3 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b2 = options.maxRetryDelayInMs) !== null && _b2 !== void 0 ? _b2 : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js
var retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
var retryPolicyName = "retryPolicy";
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger4 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request, next) {
      var _a3, _b2;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger4.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
            response = await next(request);
            logger4.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
          } catch (e) {
            logger4.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
            logger4.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError();
            throw abortError;
          }
          if (retryCount >= ((_b2 = options.maxRetries) !== null && _b2 !== void 0 ? _b2 : DEFAULT_RETRY_POLICY_COUNT)) {
            logger4.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger4.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger4.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger4.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js
var defaultRetryPolicyName = "defaultRetryPolicy";
function defaultRetryPolicy(options = {}) {
  var _a3;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== void 0 ? _a3 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.browser.js
var formDataPolicyName = "formDataPolicy";
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request, next) {
      if (request.formData) {
        const formData = request.formData;
        const requestForm = new FormData();
        for (const formKey of Object.keys(formData)) {
          const formValue = formData[formKey];
          if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
              requestForm.append(formKey, subValue);
            }
          } else {
            requestForm.append(formKey, formValue);
          }
        }
        request.body = requestForm;
        request.formData = void 0;
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = new URLSearchParams(requestForm).toString();
        } else if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
          request.headers.delete("Content-Type");
        }
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js
var errorMessage = "proxyPolicy is not supported in browser environment";
function proxyPolicy() {
  throw new Error(errorMessage);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js
var setClientRequestIdPolicyName = "setClientRequestIdPolicy";
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(requestIdHeaderName)) {
        request.headers.set(requestIdHeaderName, request.requestId);
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js
var tlsPolicyName = "tlsPolicy";
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}

// node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js
var knownContextKeys = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
function createTracingContext(options = {}) {
  let context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
var TracingContextImpl = class _TracingContextImpl {
  constructor(initialContext) {
    this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
  }
  setValue(key, value) {
    const newContext = new _TracingContextImpl(this);
    newContext._contextMap.set(key, value);
    return newContext;
  }
  getValue(key) {
    return this._contextMap.get(key);
  }
  deleteValue(key) {
    const newContext = new _TracingContextImpl(this);
    newContext._contextMap.delete(key);
    return newContext;
  }
};

// node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
var instrumenterImplementation;
function getInstrumenter() {
  if (!instrumenterImplementation) {
    instrumenterImplementation = createDefaultInstrumenter();
  }
  return instrumenterImplementation;
}

// node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name, operationOptions, spanOptions) {
    var _a3;
    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js
var custom = {};

// node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js
var errorSanitizer = new Sanitizer();
var RestError = class _RestError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = "RestError";
    this.code = options.code;
    this.statusCode = options.statusCode;
    this.request = options.request;
    this.response = options.response;
    Object.setPrototypeOf(this, _RestError.prototype);
  }
  /**
   * Logging method for util.inspect in Node
   */
  [custom]() {
    return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
  }
};
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
RestError.PARSE_ERROR = "PARSE_ERROR";
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js
var tracingPolicyName = "tracingPolicy";
function tracingPolicy(options = {}) {
  const userAgent = getUserAgentValue(options.userAgentPrefix);
  const tracingClient = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request, next) {
      var _a3, _b2;
      if (!tracingClient || !((_a3 = request.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext)) {
        return next(request);
      }
      const { span, tracingContext } = (_b2 = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b2 !== void 0 ? _b2 : {};
      if (!span || !tracingContext) {
        return next(request);
      }
      try {
        const response = await tracingClient.withContext(tracingContext, next, request);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION
    });
  } catch (e) {
    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient, request, userAgent) {
  try {
    const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
      spanKind: "client",
      spanAttributes: {
        "http.method": request.method,
        "http.url": request.url,
        requestId: request.requestId
      }
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js
function createPipelineFromOptions(options) {
  var _a3;
  const pipeline = createEmptyPipeline();
  if (isNode) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy());
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a3 = options.telemetryOptions) === null || _a3 === void 0 ? void 0 : _a3.clientRequestIdHeaderName));
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
  if (isNode) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js
function normalizeName(name) {
  return name.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
var HttpHeadersImpl = class {
  constructor(rawHeaders) {
    this._headersMap = /* @__PURE__ */ new Map();
    if (rawHeaders) {
      for (const headerName of Object.keys(rawHeaders)) {
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  set(name, value) {
    this._headersMap.set(normalizeName(name), { name, value: String(value) });
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param name - The name of the header. This value is case-insensitive.
   */
  get(name) {
    var _a3;
    return (_a3 = this._headersMap.get(normalizeName(name))) === null || _a3 === void 0 ? void 0 : _a3.value;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   * @param name - The name of the header to set. This value is case-insensitive.
   */
  has(name) {
    return this._headersMap.has(normalizeName(name));
  }
  /**
   * Remove the header with the provided headerName.
   * @param name - The name of the header to remove.
   */
  delete(name) {
    this._headersMap.delete(normalizeName(name));
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJSON(options = {}) {
    const result = {};
    if (options.preserveCase) {
      for (const entry of this._headersMap.values()) {
        result[entry.name] = entry.value;
      }
    } else {
      for (const [normalizedName, entry] of this._headersMap) {
        result[normalizedName] = entry.value;
      }
    }
    return result;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: true }));
  }
  /**
   * Iterate over tuples of header [name, value] pairs.
   */
  [Symbol.iterator]() {
    return headerIterator(this._headersMap);
  }
};
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js
function isNodeReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isReadableStream(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}
function isBlob(body) {
  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
var FetchHttpClient = class {
  /**
   * Makes a request over an underlying transport layer and returns the response.
   * @param request - The request to be made.
   */
  async sendRequest(request) {
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    if (isInsecure && !request.allowInsecureConnection) {
      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
    }
    if (request.proxySettings) {
      throw new Error("HTTP proxy is not supported in browser environment");
    }
    try {
      return await makeRequest(request);
    } catch (e) {
      throw getError(e, request);
    }
  }
};
async function makeRequest(request) {
  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
  try {
    const headers = buildFetchHeaders(request.headers);
    const { streaming, body: requestBody } = buildRequestBody(request);
    const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers, signal: abortController.signal }, "credentials" in Request.prototype ? { credentials: request.withCredentials ? "include" : "same-origin" } : {}), "cache" in Request.prototype ? { cache: "no-store" } : {});
    if (streaming) {
      requestInit.duplex = "half";
    }
    const response = await fetch(request.url, requestInit);
    if (isBlob(request.body) && request.onUploadProgress) {
      request.onUploadProgress({ loadedBytes: request.body.size });
    }
    return buildPipelineResponse(response, request, abortControllerCleanup);
  } catch (e) {
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    throw e;
  }
}
async function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {
  var _a3, _b2;
  const headers = buildPipelineHeaders(httpResponse);
  const response = {
    request,
    headers,
    status: httpResponse.status
  };
  const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {
    onProgress: request.onDownloadProgress,
    onEnd: abortControllerCleanup
  }) : httpResponse.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a3 = request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(Number.POSITIVE_INFINITY)) || ((_b2 = request.streamResponseStatusCodes) === null || _b2 === void 0 ? void 0 : _b2.has(response.status))
  ) {
    if (request.enableBrowserStreams) {
      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : void 0;
    } else {
      const responseStream = new Response(bodyStream);
      response.blobBody = responseStream.blob();
      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    }
  } else {
    const responseStream = new Response(bodyStream);
    response.bodyAsText = await responseStream.text();
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
  }
  return response;
}
function setupAbortSignal(request) {
  const abortController = new AbortController();
  let abortControllerCleanup;
  let abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new AbortError("The operation was aborted.");
    }
    abortListener = (event) => {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = () => {
      var _a3;
      if (abortListener) {
        (_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("abort", abortListener);
      }
    };
  }
  if (request.timeout > 0) {
    setTimeout(() => {
      abortController.abort();
    }, request.timeout);
  }
  return { abortController, abortControllerCleanup };
}
function getError(e, request) {
  var _a3;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new RestError(`Error sending request: ${e.message}`, {
      code: (_a3 = e === null || e === void 0 ? void 0 : e.code) !== null && _a3 !== void 0 ? _a3 : RestError.REQUEST_SEND_ERROR,
      request
    });
  }
}
function buildFetchHeaders(pipelineHeaders) {
  const headers = new Headers();
  for (const [name, value] of pipelineHeaders) {
    headers.append(name, value);
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  const responseHeaders = createHttpHeaders();
  for (const [name, value] of httpResponse.headers) {
    responseHeaders.set(name, value);
  }
  return responseHeaders;
}
function buildRequestBody(request) {
  const body = typeof request.body === "function" ? request.body() : request.body;
  if (isNodeReadableStream(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return isReadableStream(body) ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) } : { streaming: false, body };
}
function buildBodyStream(readableStream, options = {}) {
  let loadedBytes = 0;
  const { onProgress, onEnd } = options;
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      flush() {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      }
    }));
  } else {
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        var _a3;
        const { done, value } = await reader.read();
        if (done || !value) {
          onEnd === null || onEnd === void 0 ? void 0 : onEnd();
          controller.close();
          reader.releaseLock();
          return;
        }
        loadedBytes += (_a3 = value === null || value === void 0 ? void 0 : value.length) !== null && _a3 !== void 0 ? _a3 : 0;
        controller.enqueue(value);
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      cancel(reason) {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        return reader.cancel(reason);
      }
    });
  }
}
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== void 0 && self.TransformStream !== void 0;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js
function createDefaultHttpClient() {
  return createFetchHttpClient();
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js
var PipelineRequestImpl = class {
  constructor(options) {
    var _a3, _b2, _c2, _d2, _e, _f, _g;
    this.url = options.url;
    this.body = options.body;
    this.headers = (_a3 = options.headers) !== null && _a3 !== void 0 ? _a3 : createHttpHeaders();
    this.method = (_b2 = options.method) !== null && _b2 !== void 0 ? _b2 : "GET";
    this.timeout = (_c2 = options.timeout) !== null && _c2 !== void 0 ? _c2 : 0;
    this.formData = options.formData;
    this.disableKeepAlive = (_d2 = options.disableKeepAlive) !== null && _d2 !== void 0 ? _d2 : false;
    this.proxySettings = options.proxySettings;
    this.streamResponseStatusCodes = options.streamResponseStatusCodes;
    this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
    this.abortSignal = options.abortSignal;
    this.tracingOptions = options.tracingOptions;
    this.onUploadProgress = options.onUploadProgress;
    this.onDownloadProgress = options.onDownloadProgress;
    this.requestId = options.requestId || randomUUID();
    this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
    this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
  }
};
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js
var DEFAULT_CYCLER_OPTIONS = {
  forcedRefreshWindowInMs: 1e3,
  retryIntervalInMs: 3e3,
  refreshWindowInMs: 1e3 * 60 * 2
  // Start refreshing 2m before expiry
};
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a3) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a3;
      return !cycler.isRefreshing && ((_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a3;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
    if (mustRefresh)
      return refresh(scopes, tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js
var bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request } = options;
  const getTokenOptions = {
    abortSignal: request.abortSignal,
    tracingOptions: request.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a3;
  const { credential, scopes, challengeCallbacks } = options;
  const logger4 = options.logger || logger;
  const callbacks = Object.assign({ authorizeRequest: (_a3 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a3 !== void 0 ? _a3 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request,
        getAccessToken,
        logger: logger4
      });
      let response;
      let error;
      try {
        response = await next(request);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          response,
          getAccessToken,
          logger: logger4
        });
        if (shouldSendRequest) {
          return next(request);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/apiVersionPolicy.js
var apiVersionPolicyName = "ApiVersionPolicy";
function apiVersionPolicy(options) {
  return {
    name: apiVersionPolicyName,
    sendRequest: (req, next) => {
      const url = new URL(req.url);
      if (!url.searchParams.get("api-version") && options.apiVersion) {
        req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
      }
      return next(req);
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/keyCredentialAuthenticationPolicy.js
var keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
function keyCredentialAuthenticationPolicy(credential, apiKeyHeaderName) {
  return {
    name: keyCredentialAuthenticationPolicyName,
    async sendRequest(request, next) {
      request.headers.set(apiKeyHeaderName, credential.key);
      return next(request);
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/clientHelpers.js
var cachedHttpClient;
function addCredentialPipelinePolicy(pipeline, baseUrl, options = {}) {
  var _a3, _b2, _c2, _d2;
  const { credential, clientOptions } = options;
  if (!credential) {
    return;
  }
  if (isTokenCredential(credential)) {
    const tokenPolicy = bearerTokenAuthenticationPolicy({
      credential,
      scopes: (_b2 = (_a3 = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _a3 === void 0 ? void 0 : _a3.scopes) !== null && _b2 !== void 0 ? _b2 : `${baseUrl}/.default`
    });
    pipeline.addPolicy(tokenPolicy);
  } else if (isKeyCredential(credential)) {
    if (!((_c2 = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _c2 === void 0 ? void 0 : _c2.apiKeyHeaderName)) {
      throw new Error(`Missing API Key Header Name`);
    }
    const keyPolicy = keyCredentialAuthenticationPolicy(credential, (_d2 = clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.credentials) === null || _d2 === void 0 ? void 0 : _d2.apiKeyHeaderName);
    pipeline.addPolicy(keyPolicy);
  }
}
function createDefaultPipeline(baseUrl, credential, options = {}) {
  const pipeline = createPipelineFromOptions(options);
  pipeline.addPolicy(apiVersionPolicy(options));
  addCredentialPipelinePolicy(pipeline, baseUrl, { credential, clientOptions: options });
  return pipeline;
}
function isKeyCredential(credential) {
  return credential.key !== void 0;
}
function getCachedDefaultHttpsClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@azure-rest/core-client/dist-esm/src/operationOptionHelpers.js
function operationOptionsToRequestParameters(options) {
  var _a3, _b2, _c2, _d2, _e, _f;
  return {
    allowInsecureConnection: (_a3 = options.requestOptions) === null || _a3 === void 0 ? void 0 : _a3.allowInsecureConnection,
    timeout: (_b2 = options.requestOptions) === null || _b2 === void 0 ? void 0 : _b2.timeout,
    skipUrlEncoding: (_c2 = options.requestOptions) === null || _c2 === void 0 ? void 0 : _c2.skipUrlEncoding,
    abortSignal: options.abortSignal,
    onUploadProgress: (_d2 = options.requestOptions) === null || _d2 === void 0 ? void 0 : _d2.onUploadProgress,
    onDownloadProgress: (_e = options.requestOptions) === null || _e === void 0 ? void 0 : _e.onDownloadProgress,
    tracingOptions: options.tracingOptions,
    headers: Object.assign({}, (_f = options.requestOptions) === null || _f === void 0 ? void 0 : _f.headers),
    onResponse: options.onResponse
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/helpers/isReadableStream.browser.js
function isReadableStream2(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}

// node_modules/@azure-rest/core-client/dist-esm/src/helpers/getBinaryBody.js
function binaryArrayToString(content) {
  let decodedBody = "";
  for (const element of content) {
    decodedBody += String.fromCharCode(element);
  }
  return decodedBody;
}

// node_modules/@azure-rest/core-client/dist-esm/src/sendRequest.js
async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
  const request = buildPipelineRequest(method, url, options);
  const response = await pipeline.sendRequest(httpClient, request);
  const rawHeaders = response.headers.toJSON();
  const parsedBody = getResponseBody(response);
  if (options === null || options === void 0 ? void 0 : options.onResponse) {
    options.onResponse(Object.assign(Object.assign({}, response), { request, rawHeaders, parsedBody }));
  }
  return {
    request,
    headers: rawHeaders,
    status: `${response.status}`,
    body: parsedBody
  };
}
async function sendRequestAsStream(method, url, pipeline, options = {}, customHttpClient) {
  var _a3;
  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
  const request = buildPipelineRequest(method, url, Object.assign(Object.assign({}, options), { responseAsStream: true }));
  const response = await pipeline.sendRequest(httpClient, request);
  const rawHeaders = response.headers.toJSON();
  const parsedBody = (_a3 = response.browserStreamBody) !== null && _a3 !== void 0 ? _a3 : response.readableStreamBody;
  return {
    request,
    headers: rawHeaders,
    status: `${response.status}`,
    body: parsedBody
  };
}
function getContentType(body) {
  if (ArrayBuffer.isView(body)) {
    return "application/octet-stream";
  }
  return "application/json; charset=UTF-8";
}
function buildPipelineRequest(method, url, options = {}) {
  var _a3, _b2;
  const { body, formData } = getRequestBody(options.body, options.contentType);
  const hasContent = body !== void 0 || formData !== void 0;
  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), { accept: (_a3 = options.accept) !== null && _a3 !== void 0 ? _a3 : "application/json" }), hasContent && {
    "content-type": (_b2 = options.contentType) !== null && _b2 !== void 0 ? _b2 : getContentType(options.body)
  }));
  return createPipelineRequest({
    url,
    method,
    body,
    formData,
    headers,
    allowInsecureConnection: options.allowInsecureConnection,
    tracingOptions: options.tracingOptions,
    abortSignal: options.abortSignal,
    onUploadProgress: options.onUploadProgress,
    onDownloadProgress: options.onDownloadProgress,
    timeout: options.timeout,
    enableBrowserStreams: true,
    streamResponseStatusCodes: options.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
  });
}
function getRequestBody(body, contentType = "") {
  if (body === void 0) {
    return { body: void 0 };
  }
  if (isReadableStream2(body)) {
    return { body };
  }
  if (!contentType && typeof body === "string") {
    return { body };
  }
  const firstType = contentType.split(";")[0];
  if (firstType === "application/json") {
    return { body: JSON.stringify(body) };
  }
  if (ArrayBuffer.isView(body)) {
    if (body instanceof Uint8Array) {
      return firstType === "application/octet-stream" ? { body } : { body: binaryArrayToString(body) };
    } else {
      return { body: JSON.stringify(body) };
    }
  }
  switch (firstType) {
    case "multipart/form-data":
      return isFormData(body) ? { formData: processFormData(body) } : { body: JSON.stringify(body) };
    case "text/plain":
      return { body: String(body) };
    default:
      if (typeof body === "string") {
        return { body };
      }
      return { body: JSON.stringify(body) };
  }
}
function isFormData(body) {
  return body instanceof Object && Object.keys(body).length > 0;
}
function processFormData(formData) {
  if (!formData) {
    return formData;
  }
  const processedFormData = {};
  for (const element in formData) {
    const item = formData[element];
    if (item instanceof Uint8Array) {
      processedFormData[element] = binaryArrayToString(item);
    } else {
      processedFormData[element] = item;
    }
  }
  return processedFormData;
}
function getResponseBody(response) {
  var _a3, _b2;
  const contentType = (_a3 = response.headers.get("content-type")) !== null && _a3 !== void 0 ? _a3 : "";
  const firstType = contentType.split(";")[0];
  const bodyToParse = (_b2 = response.bodyAsText) !== null && _b2 !== void 0 ? _b2 : "";
  if (firstType === "text/plain") {
    return String(bodyToParse);
  }
  try {
    return bodyToParse ? JSON.parse(bodyToParse) : void 0;
  } catch (error) {
    if (firstType === "application/json") {
      throw createParseError(response, error);
    }
    return String(bodyToParse);
  }
}
function createParseError(response, err) {
  var _a3;
  const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
  const errCode = (_a3 = err.code) !== null && _a3 !== void 0 ? _a3 : RestError.PARSE_ERROR;
  return new RestError(msg, {
    code: errCode,
    statusCode: response.status,
    request: response.request,
    response
  });
}

// node_modules/@azure-rest/core-client/dist-esm/src/urlHelpers.js
function buildRequestUrl(baseUrl, routePath, pathParameters, options = {}) {
  if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
    return routePath;
  }
  baseUrl = buildBaseUrl(baseUrl, options);
  routePath = buildRoutePath(routePath, pathParameters, options);
  const requestUrl = appendQueryParams(`${baseUrl}/${routePath}`, options);
  const url = new URL(requestUrl);
  return url.toString().replace(/([^:]\/)\/+/g, "$1");
}
function appendQueryParams(url, options = {}) {
  if (!options.queryParameters) {
    return url;
  }
  let parsedUrl = new URL(url);
  const queryParams = options.queryParameters;
  for (const key of Object.keys(queryParams)) {
    const param = queryParams[key];
    if (param === void 0 || param === null) {
      continue;
    }
    if (!param.toString || typeof param.toString !== "function") {
      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
    }
    const value = param.toISOString !== void 0 ? param.toISOString() : param.toString();
    parsedUrl.searchParams.append(key, value);
  }
  if (options.skipUrlEncoding) {
    parsedUrl = skipQueryParameterEncoding(parsedUrl);
  }
  return parsedUrl.toString();
}
function skipQueryParameterEncoding(url) {
  if (!url) {
    return url;
  }
  const searchPieces = [];
  for (const [name, value] of url.searchParams) {
    searchPieces.push(`${name}=${value}`);
  }
  url.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return url;
}
function buildBaseUrl(baseUrl, options) {
  var _a3;
  if (!options.pathParameters) {
    return baseUrl;
  }
  const pathParams = options.pathParameters;
  for (const [key, param] of Object.entries(pathParams)) {
    if (param === void 0 || param === null) {
      throw new Error(`Path parameters ${key} must not be undefined or null`);
    }
    if (!param.toString || typeof param.toString !== "function") {
      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
    }
    let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
    if (!options.skipUrlEncoding) {
      value = encodeURIComponent(param);
    }
    baseUrl = (_a3 = replaceAll(baseUrl, `{${key}}`, value)) !== null && _a3 !== void 0 ? _a3 : "";
  }
  return baseUrl;
}
function buildRoutePath(routePath, pathParameters, options = {}) {
  for (const pathParam of pathParameters) {
    let value = pathParam;
    if (!options.skipUrlEncoding) {
      value = encodeURIComponent(pathParam);
    }
    routePath = routePath.replace(/\{\w+\}/, value);
  }
  return routePath;
}
function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}

// node_modules/@azure-rest/core-client/dist-esm/src/getClient.js
function getClient(baseUrl, credentialsOrPipelineOptions, clientOptions = {}) {
  var _a3;
  let credentials;
  if (credentialsOrPipelineOptions) {
    if (isCredential(credentialsOrPipelineOptions)) {
      credentials = credentialsOrPipelineOptions;
    } else {
      clientOptions = credentialsOrPipelineOptions !== null && credentialsOrPipelineOptions !== void 0 ? credentialsOrPipelineOptions : {};
    }
  }
  const pipeline = createDefaultPipeline(baseUrl, credentials, clientOptions);
  if ((_a3 = clientOptions.additionalPolicies) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const { policy, position } of clientOptions.additionalPolicies) {
      const afterPhase = position === "perRetry" ? "Sign" : void 0;
      pipeline.addPolicy(policy, {
        afterPhase
      });
    }
  }
  const { allowInsecureConnection, httpClient } = clientOptions;
  const client = (path, ...args) => {
    const getUrl = (requestOptions) => buildRequestUrl(baseUrl, path, args, Object.assign({ allowInsecureConnection }, requestOptions));
    return {
      get: (requestOptions = {}) => {
        return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      post: (requestOptions = {}) => {
        return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      put: (requestOptions = {}) => {
        return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      patch: (requestOptions = {}) => {
        return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      delete: (requestOptions = {}) => {
        return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      head: (requestOptions = {}) => {
        return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      options: (requestOptions = {}) => {
        return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      trace: (requestOptions = {}) => {
        return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      }
    };
  };
  return {
    path: client,
    pathUnchecked: client,
    pipeline
  };
}
function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
  var _a3;
  allowInsecureConnection = (_a3 = options.allowInsecureConnection) !== null && _a3 !== void 0 ? _a3 : allowInsecureConnection;
  return {
    then: function(onFulfilled, onrejected) {
      return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection }), httpClient).then(onFulfilled, onrejected);
    },
    async asBrowserStream() {
      return sendRequestAsStream(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection }), httpClient);
    },
    async asNodeStream() {
      return sendRequestAsStream(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection }), httpClient);
    }
  };
}
function isCredential(param) {
  if (param.key !== void 0 || isTokenCredential(param)) {
    return true;
  }
  return false;
}

// node_modules/@azure/openai/dist-esm/src/logger.js
var logger2 = createClientLogger("openai");

// node_modules/@azure/openai/dist-esm/src/rest/openAIClient.js
function createClient(endpoint, credentials, options = {}) {
  var _a3, _b2, _c2, _d2, _e, _f, _g, _h;
  const baseUrl = (_a3 = options.baseUrl) !== null && _a3 !== void 0 ? _a3 : `${endpoint}/openai`;
  options.apiVersion = (_b2 = options.apiVersion) !== null && _b2 !== void 0 ? _b2 : "2023-09-01-preview";
  options = Object.assign(Object.assign({}, options), { credentials: {
    scopes: (_d2 = (_c2 = options.credentials) === null || _c2 === void 0 ? void 0 : _c2.scopes) !== null && _d2 !== void 0 ? _d2 : ["https://cognitiveservices.azure.com/.default"],
    apiKeyHeaderName: (_f = (_e = options.credentials) === null || _e === void 0 ? void 0 : _e.apiKeyHeaderName) !== null && _f !== void 0 ? _f : "api-key"
  } });
  const userAgentInfo = `azsdk-js-openai-rest/1.0.0-beta.7`;
  const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}` : `${userAgentInfo}`;
  options = Object.assign(Object.assign({}, options), { userAgentOptions: {
    userAgentPrefix
  }, loggingOptions: {
    logger: (_h = (_g = options.loggingOptions) === null || _g === void 0 ? void 0 : _g.logger) !== null && _h !== void 0 ? _h : logger2.info
  } });
  const client = getClient(baseUrl, credentials, options);
  return client;
}

// node_modules/@azure/openai/dist-esm/src/rest/isUnexpected.js
var responseMap = {
  "POST /deployments/{deploymentId}/embeddings": ["200"],
  "POST /deployments/{deploymentId}/completions": ["200"],
  "POST /deployments/{deploymentId}/chat/completions": ["200"],
  "POST /deployments/{deploymentId}/extensions/chat/completions": ["200"],
  "GET /operations/images/{operationId}": ["200"],
  "POST /images/generations:submit": ["202"],
  "GET /images/generations:submit": ["200", "202"]
};
function isUnexpected(response) {
  const lroOriginal = response.headers["x-ms-original-url"];
  const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
  const method = response.request.method;
  let pathDetails = responseMap[`${method} ${url.pathname}`];
  if (!pathDetails) {
    pathDetails = getParametrizedPathSuccess(method, url.pathname);
  }
  return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
  var _a3, _b2, _c2, _d2;
  const pathParts = path.split("/");
  let matchedLen = -1, matchedValue = [];
  for (const [key, value] of Object.entries(responseMap)) {
    if (!key.startsWith(method)) {
      continue;
    }
    const candidatePath = getPathFromMapKey(key);
    const candidateParts = candidatePath.split("/");
    let found = true;
    for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
      if (((_a3 = candidateParts[i]) === null || _a3 === void 0 ? void 0 : _a3.startsWith("{")) && ((_b2 = candidateParts[i]) === null || _b2 === void 0 ? void 0 : _b2.indexOf("}")) !== -1) {
        const start = candidateParts[i].indexOf("}") + 1, end = (_c2 = candidateParts[i]) === null || _c2 === void 0 ? void 0 : _c2.length;
        const isMatched = new RegExp(`${(_d2 = candidateParts[i]) === null || _d2 === void 0 ? void 0 : _d2.slice(start, end)}`).test(pathParts[j] || "");
        if (!isMatched) {
          found = false;
          break;
        }
        continue;
      }
      if (candidateParts[i] !== pathParts[j]) {
        found = false;
        break;
      }
    }
    if (found && candidatePath.length > matchedLen) {
      matchedLen = candidatePath.length;
      matchedValue = value;
    }
  }
  return matchedValue;
}
function getPathFromMapKey(mapKey) {
  const pathStart = mapKey.indexOf("/");
  return mapKey.slice(pathStart);
}

// node_modules/@azure/core-lro/dist-esm/src/logger.js
var logger3 = createClientLogger("core-lro");

// node_modules/@azure/core-lro/dist-esm/src/poller/constants.js
var POLL_INTERVAL_IN_MS = 2e3;
var terminalStates = ["succeeded", "canceled", "failed"];

// node_modules/@azure/core-lro/dist-esm/src/poller/operation.js
function deserializeState(serializedState) {
  try {
    return JSON.parse(serializedState).state;
  } catch (e) {
    throw new Error(`Unable to deserialize input state: ${serializedState}`);
  }
}
function setStateError(inputs) {
  const { state, stateProxy, isOperationError: isOperationError2 } = inputs;
  return (error) => {
    if (isOperationError2(error)) {
      stateProxy.setError(state, error);
      stateProxy.setFailed(state);
    }
    throw error;
  };
}
function appendReadableErrorMessage(currentMessage, innerMessage) {
  let message = currentMessage;
  if (message.slice(-1) !== ".") {
    message = message + ".";
  }
  return message + " " + innerMessage;
}
function simplifyError(err) {
  let message = err.message;
  let code = err.code;
  let curErr = err;
  while (curErr.innererror) {
    curErr = curErr.innererror;
    code = curErr.code;
    message = appendReadableErrorMessage(message, curErr.message);
  }
  return {
    code,
    message
  };
}
function processOperationStatus(result) {
  const { state, stateProxy, status, isDone, processResult, getError: getError2, response, setErrorAsResult } = result;
  switch (status) {
    case "succeeded": {
      stateProxy.setSucceeded(state);
      break;
    }
    case "failed": {
      const err = getError2 === null || getError2 === void 0 ? void 0 : getError2(response);
      let postfix = "";
      if (err) {
        const { code, message } = simplifyError(err);
        postfix = `. ${code}. ${message}`;
      }
      const errStr = `The long-running operation has failed${postfix}`;
      stateProxy.setError(state, new Error(errStr));
      stateProxy.setFailed(state);
      logger3.warning(errStr);
      break;
    }
    case "canceled": {
      stateProxy.setCanceled(state);
      break;
    }
  }
  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === void 0 && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
    stateProxy.setResult(state, buildResult({
      response,
      state,
      processResult
    }));
  }
}
function buildResult(inputs) {
  const { processResult, response, state } = inputs;
  return processResult ? processResult(response, state) : response;
}
async function initOperation(inputs) {
  const { init, stateProxy, processResult, getOperationStatus: getOperationStatus2, withOperationLocation, setErrorAsResult } = inputs;
  const { operationLocation, resourceLocation, metadata, response } = await init();
  if (operationLocation)
    withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
  const config = {
    metadata,
    operationLocation,
    resourceLocation
  };
  logger3.verbose(`LRO: Operation description:`, config);
  const state = stateProxy.initState(config);
  const status = getOperationStatus2({ response, state, operationLocation });
  processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });
  return state;
}
async function pollOperationHelper(inputs) {
  const { poll, state, stateProxy, operationLocation, getOperationStatus: getOperationStatus2, getResourceLocation: getResourceLocation2, isOperationError: isOperationError2, options } = inputs;
  const response = await poll(operationLocation, options).catch(setStateError({
    state,
    stateProxy,
    isOperationError: isOperationError2
  }));
  const status = getOperationStatus2(response, state);
  logger3.verbose(`LRO: Status:
	Polling from: ${state.config.operationLocation}
	Operation status: ${status}
	Polling status: ${terminalStates.includes(status) ? "Stopped" : "Running"}`);
  if (status === "succeeded") {
    const resourceLocation = getResourceLocation2(response, state);
    if (resourceLocation !== void 0) {
      return {
        response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError: isOperationError2 })),
        status
      };
    }
  }
  return { response, status };
}
async function pollOperation(inputs) {
  const { poll, state, stateProxy, options, getOperationStatus: getOperationStatus2, getResourceLocation: getResourceLocation2, getOperationLocation: getOperationLocation2, isOperationError: isOperationError2, withOperationLocation, getPollingInterval, processResult, getError: getError2, updateState, setDelay, isDone, setErrorAsResult } = inputs;
  const { operationLocation } = state.config;
  if (operationLocation !== void 0) {
    const { response, status } = await pollOperationHelper({
      poll,
      getOperationStatus: getOperationStatus2,
      state,
      stateProxy,
      operationLocation,
      getResourceLocation: getResourceLocation2,
      isOperationError: isOperationError2,
      options
    });
    processOperationStatus({
      status,
      response,
      state,
      stateProxy,
      isDone,
      processResult,
      getError: getError2,
      setErrorAsResult
    });
    if (!terminalStates.includes(status)) {
      const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
      if (intervalInMs)
        setDelay(intervalInMs);
      const location = getOperationLocation2 === null || getOperationLocation2 === void 0 ? void 0 : getOperationLocation2(response, state);
      if (location !== void 0) {
        const isUpdated = operationLocation !== location;
        state.config.operationLocation = location;
        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);
      } else
        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
    }
    updateState === null || updateState === void 0 ? void 0 : updateState(state, response);
  }
}

// node_modules/@azure/core-lro/dist-esm/src/http/operation.js
function getOperationLocationPollingUrl(inputs) {
  const { azureAsyncOperation, operationLocation } = inputs;
  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
}
function getLocationHeader(rawResponse) {
  return rawResponse.headers["location"];
}
function getOperationLocationHeader(rawResponse) {
  return rawResponse.headers["operation-location"];
}
function getAzureAsyncOperationHeader(rawResponse) {
  return rawResponse.headers["azure-asyncoperation"];
}
function findResourceLocation(inputs) {
  var _a3;
  const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
  switch (requestMethod) {
    case "PUT": {
      return requestPath;
    }
    case "DELETE": {
      return void 0;
    }
    case "PATCH": {
      return (_a3 = getDefault()) !== null && _a3 !== void 0 ? _a3 : requestPath;
    }
    default: {
      return getDefault();
    }
  }
  function getDefault() {
    switch (resourceLocationConfig) {
      case "azure-async-operation": {
        return void 0;
      }
      case "original-uri": {
        return requestPath;
      }
      case "location":
      default: {
        return location;
      }
    }
  }
}
function inferLroMode(inputs) {
  const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
  const operationLocation = getOperationLocationHeader(rawResponse);
  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
  const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
  const location = getLocationHeader(rawResponse);
  const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
  if (pollingUrl !== void 0) {
    return {
      mode: "OperationLocation",
      operationLocation: pollingUrl,
      resourceLocation: findResourceLocation({
        requestMethod: normalizedRequestMethod,
        location,
        requestPath,
        resourceLocationConfig
      })
    };
  } else if (location !== void 0) {
    return {
      mode: "ResourceLocation",
      operationLocation: location
    };
  } else if (normalizedRequestMethod === "PUT" && requestPath) {
    return {
      mode: "Body",
      operationLocation: requestPath
    };
  } else {
    return void 0;
  }
}
function transformStatus(inputs) {
  const { status, statusCode } = inputs;
  if (typeof status !== "string" && status !== void 0) {
    throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
  }
  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
    case void 0:
      return toOperationStatus(statusCode);
    case "succeeded":
      return "succeeded";
    case "failed":
      return "failed";
    case "running":
    case "accepted":
    case "started":
    case "canceling":
    case "cancelling":
      return "running";
    case "canceled":
    case "cancelled":
      return "canceled";
    default: {
      logger3.verbose(`LRO: unrecognized operation status: ${status}`);
      return status;
    }
  }
}
function getStatus(rawResponse) {
  var _a3;
  const { status } = (_a3 = rawResponse.body) !== null && _a3 !== void 0 ? _a3 : {};
  return transformStatus({ status, statusCode: rawResponse.statusCode });
}
function getProvisioningState(rawResponse) {
  var _a3, _b2;
  const { properties, provisioningState } = (_a3 = rawResponse.body) !== null && _a3 !== void 0 ? _a3 : {};
  const status = (_b2 = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b2 !== void 0 ? _b2 : provisioningState;
  return transformStatus({ status, statusCode: rawResponse.statusCode });
}
function toOperationStatus(statusCode) {
  if (statusCode === 202) {
    return "running";
  } else if (statusCode < 300) {
    return "succeeded";
  } else {
    return "failed";
  }
}
function parseRetryAfter({ rawResponse }) {
  const retryAfter = rawResponse.headers["retry-after"];
  if (retryAfter !== void 0) {
    const retryAfterInSeconds = parseInt(retryAfter);
    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1e3;
  }
  return void 0;
}
function getErrorFromResponse(response) {
  const error = response.flatResponse.error;
  if (!error) {
    logger3.warning(`The long-running operation failed but there is no error property in the response's body`);
    return;
  }
  if (!error.code || !error.message) {
    logger3.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
    return;
  }
  return error;
}
function calculatePollingIntervalFromDate(retryAfterDate) {
  const timeNow = Math.floor((/* @__PURE__ */ new Date()).getTime());
  const retryAfterTime = retryAfterDate.getTime();
  if (timeNow < retryAfterTime) {
    return retryAfterTime - timeNow;
  }
  return void 0;
}
function getStatusFromInitialResponse(inputs) {
  const { response, state, operationLocation } = inputs;
  function helper() {
    var _a3;
    const mode = (_a3 = state.config.metadata) === null || _a3 === void 0 ? void 0 : _a3["mode"];
    switch (mode) {
      case void 0:
        return toOperationStatus(response.rawResponse.statusCode);
      case "Body":
        return getOperationStatus(response, state);
      default:
        return "running";
    }
  }
  const status = helper();
  return status === "running" && operationLocation === void 0 ? "succeeded" : status;
}
function getOperationLocation({ rawResponse }, state) {
  var _a3;
  const mode = (_a3 = state.config.metadata) === null || _a3 === void 0 ? void 0 : _a3["mode"];
  switch (mode) {
    case "OperationLocation": {
      return getOperationLocationPollingUrl({
        operationLocation: getOperationLocationHeader(rawResponse),
        azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
      });
    }
    case "ResourceLocation": {
      return getLocationHeader(rawResponse);
    }
    case "Body":
    default: {
      return void 0;
    }
  }
}
function getOperationStatus({ rawResponse }, state) {
  var _a3;
  const mode = (_a3 = state.config.metadata) === null || _a3 === void 0 ? void 0 : _a3["mode"];
  switch (mode) {
    case "OperationLocation": {
      return getStatus(rawResponse);
    }
    case "ResourceLocation": {
      return toOperationStatus(rawResponse.statusCode);
    }
    case "Body": {
      return getProvisioningState(rawResponse);
    }
    default:
      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
  }
}
function getResourceLocation({ flatResponse }, state) {
  if (typeof flatResponse === "object") {
    const resourceLocation = flatResponse.resourceLocation;
    if (resourceLocation !== void 0) {
      state.config.resourceLocation = resourceLocation;
    }
  }
  return state.config.resourceLocation;
}
function isOperationError(e) {
  return e.name === "RestError";
}

// node_modules/@azure/core-lro/dist-esm/src/poller/poller.js
var createStateProxy = () => ({
  /**
   * The state at this point is created to be of type OperationState<TResult>.
   * It will be updated later to be of type TState when the
   * customer-provided callback, `updateState`, is called during polling.
   */
  initState: (config) => ({ status: "running", config }),
  setCanceled: (state) => state.status = "canceled",
  setError: (state, error) => state.error = error,
  setResult: (state, result) => state.result = result,
  setRunning: (state) => state.status = "running",
  setSucceeded: (state) => state.status = "succeeded",
  setFailed: (state) => state.status = "failed",
  getError: (state) => state.error,
  getResult: (state) => state.result,
  isCanceled: (state) => state.status === "canceled",
  isFailed: (state) => state.status === "failed",
  isRunning: (state) => state.status === "running",
  isSucceeded: (state) => state.status === "succeeded"
});
function buildCreatePoller(inputs) {
  const { getOperationLocation: getOperationLocation2, getStatusFromInitialResponse: getStatusFromInitialResponse2, getStatusFromPollResponse, isOperationError: isOperationError2, getResourceLocation: getResourceLocation2, getPollingInterval, getError: getError2, resolveOnUnsuccessful } = inputs;
  return async ({ init, poll }, options) => {
    const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
    const stateProxy = createStateProxy();
    const withOperationLocation = withOperationLocationCallback ? /* @__PURE__ */ (() => {
      let called = false;
      return (operationLocation, isUpdated) => {
        if (isUpdated)
          withOperationLocationCallback(operationLocation);
        else if (!called)
          withOperationLocationCallback(operationLocation);
        called = true;
      };
    })() : void 0;
    const state = restoreFrom ? deserializeState(restoreFrom) : await initOperation({
      init,
      stateProxy,
      processResult,
      getOperationStatus: getStatusFromInitialResponse2,
      withOperationLocation,
      setErrorAsResult: !resolveOnUnsuccessful
    });
    let resultPromise;
    const abortController = new AbortController2();
    const handlers = /* @__PURE__ */ new Map();
    const handleProgressEvents = async () => handlers.forEach((h) => h(state));
    const cancelErrMsg = "Operation was canceled";
    let currentPollIntervalInMs = intervalInMs;
    const poller = {
      getOperationState: () => state,
      getResult: () => state.result,
      isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
      isStopped: () => resultPromise === void 0,
      stopPolling: () => {
        abortController.abort();
      },
      toString: () => JSON.stringify({
        state
      }),
      onProgress: (callback) => {
        const s = Symbol();
        handlers.set(s, callback);
        return () => handlers.delete(s);
      },
      pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {
        const { abortSignal: inputAbortSignal } = pollOptions || {};
        const { signal: abortSignal2 } = inputAbortSignal ? new AbortController2([inputAbortSignal, abortController.signal]) : abortController;
        if (!poller.isDone()) {
          await poller.poll({ abortSignal: abortSignal2 });
          while (!poller.isDone()) {
            await delay(currentPollIntervalInMs, { abortSignal: abortSignal2 });
            await poller.poll({ abortSignal: abortSignal2 });
          }
        }
        if (resolveOnUnsuccessful) {
          return poller.getResult();
        } else {
          switch (state.status) {
            case "succeeded":
              return poller.getResult();
            case "canceled":
              throw new Error(cancelErrMsg);
            case "failed":
              throw state.error;
            case "notStarted":
            case "running":
              throw new Error(`Polling completed without succeeding or failing`);
          }
        }
      })().finally(() => {
        resultPromise = void 0;
      }),
      async poll(pollOptions) {
        if (resolveOnUnsuccessful) {
          if (poller.isDone())
            return;
        } else {
          switch (state.status) {
            case "succeeded":
              return;
            case "canceled":
              throw new Error(cancelErrMsg);
            case "failed":
              throw state.error;
          }
        }
        await pollOperation({
          poll,
          state,
          stateProxy,
          getOperationLocation: getOperationLocation2,
          isOperationError: isOperationError2,
          withOperationLocation,
          getPollingInterval,
          getOperationStatus: getStatusFromPollResponse,
          getResourceLocation: getResourceLocation2,
          processResult,
          getError: getError2,
          updateState,
          options: pollOptions,
          setDelay: (pollIntervalInMs) => {
            currentPollIntervalInMs = pollIntervalInMs;
          },
          setErrorAsResult: !resolveOnUnsuccessful
        });
        await handleProgressEvents();
        if (!resolveOnUnsuccessful) {
          switch (state.status) {
            case "canceled":
              throw new Error(cancelErrMsg);
            case "failed":
              throw state.error;
          }
        }
      }
    };
    return poller;
  };
}

// node_modules/@azure/core-lro/dist-esm/src/http/poller.js
async function createHttpPoller(lro, options) {
  const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
  return buildCreatePoller({
    getStatusFromInitialResponse,
    getStatusFromPollResponse: getOperationStatus,
    isOperationError,
    getOperationLocation,
    getResourceLocation,
    getPollingInterval: parseRetryAfter,
    getError: getErrorFromResponse,
    resolveOnUnsuccessful
  })({
    init: async () => {
      const response = await lro.sendInitialRequest();
      const config = inferLroMode({
        rawResponse: response.rawResponse,
        requestPath: lro.requestPath,
        requestMethod: lro.requestMethod,
        resourceLocationConfig
      });
      return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
    },
    poll: lro.sendPollRequest
  }, {
    intervalInMs,
    withOperationLocation,
    restoreFrom,
    updateState,
    processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
  });
}

// node_modules/@azure/openai/dist-esm/src/rest/pollingHelper.js
async function getLongRunningPoller(client, initialResponse, options = {}) {
  var _a3;
  const poller = {
    requestMethod: initialResponse.request.method,
    requestPath: initialResponse.request.url,
    sendInitialRequest: async () => {
      return getLroResponse(initialResponse);
    },
    sendPollRequest: async (path) => {
      const response = await client.pathUnchecked(path !== null && path !== void 0 ? path : initialResponse.request.url).get();
      const lroResponse = getLroResponse(response);
      lroResponse.rawResponse.headers["x-ms-original-url"] = initialResponse.request.url;
      return lroResponse;
    }
  };
  options.resolveOnUnsuccessful = (_a3 = options.resolveOnUnsuccessful) !== null && _a3 !== void 0 ? _a3 : true;
  return createHttpPoller(poller, options);
}
function getLroResponse(response) {
  if (Number.isNaN(response.status)) {
    throw new TypeError(`Status code of the response is not a number. Value: ${response.status}`);
  }
  return {
    flatResponse: response,
    rawResponse: Object.assign(Object.assign({}, response), { statusCode: Number.parseInt(response.status), body: response.body })
  };
}

// node_modules/@azure/openai/dist-esm/src/rest/index.js
var rest_default = createClient;

// node_modules/@azure/openai/dist-esm/src/api/OpenAIContext.js
function createOpenAI(endpoint, credential, options = {}) {
  const baseUrl = endpoint;
  const clientContext = rest_default(baseUrl, credential, options);
  return clientContext;
}

// node_modules/@azure/openai/dist-esm/src/api/deserializers.js
function getPromptFilterResult(body) {
  var _a3;
  const res = (_a3 = body["prompt_annotations"]) !== null && _a3 !== void 0 ? _a3 : body["prompt_filter_results"];
  return !res ? {} : {
    promptFilterResults: res.map((p) => Object.assign({ promptIndex: p["prompt_index"] }, !p.content_filter_results ? {} : {
      contentFilterResults: deserializeContentFilter(p.content_filter_results)
    }))
  };
}
function getCompletionsResult(body) {
  var _a3;
  return Object.assign(Object.assign({ id: body["id"], created: new Date(body["created"]) }, getPromptFilterResult(body)), { choices: ((_a3 = body["choices"]) !== null && _a3 !== void 0 ? _a3 : []).map((p) => Object.assign(Object.assign({ text: p["text"], index: p["index"] }, !p.content_filter_results ? {} : {
    contentFilterResults: deserializeContentFilter(p.content_filter_results)
  }), { logprobs: p.logprobs === null ? null : {
    tokens: p.logprobs["tokens"],
    tokenLogprobs: p.logprobs["token_logprobs"],
    topLogprobs: p.logprobs["top_logprobs"],
    textOffset: p.logprobs["text_offset"]
  }, finishReason: p["finish_reason"] })) });
}
function getChatCompletionsResult(body) {
  var _a3;
  return Object.assign(Object.assign({ id: body["id"], created: new Date(body["created"]), choices: ((_a3 = body["choices"]) !== null && _a3 !== void 0 ? _a3 : []).map((p) => Object.assign(Object.assign(Object.assign(Object.assign({}, !p.message ? {} : { message: _deserializeMessage(p.message) }), { index: p["index"], finishReason: p["finish_reason"] }), !p.delta ? {} : { delta: _deserializeMessage(p.delta) }), !p.content_filter_results ? {} : { contentFilterResults: deserializeContentFilter(p.content_filter_results) })) }, getPromptFilterResult(body)), !body["usage"] ? {} : {
    usage: {
      completionTokens: body["usage"].completion_tokens,
      promptTokens: body["usage"].prompt_tokens,
      totalTokens: body["usage"].total_tokens
    }
  });
}
function _deserializeMessage(message) {
  var _a3, _b2;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, !message["role"] ? {} : { role: message["role"] }), !message["content"] ? {} : { content: message["content"] }), !message["name"] ? {} : { name: message["name"] }), !message.function_call ? {} : {
    functionCall: {
      name: (_a3 = message.function_call) === null || _a3 === void 0 ? void 0 : _a3["name"],
      arguments: (_b2 = message.function_call) === null || _b2 === void 0 ? void 0 : _b2["arguments"]
    }
  }), !message.context ? {} : {
    context: Object.assign({}, !message.context.messages ? {} : {
      messages: message.context.messages.map((m) => {
        return _deserializeMessage(m);
      })
    })
  });
}
function deserializeContentFilter(result) {
  var _a3, _b2, _c2, _d2, _e, _f, _g, _h, _j;
  if (result.error) {
    return {
      error: {
        code: result.error.code,
        message: result.error.message,
        details: (_a3 = result.error.details) !== null && _a3 !== void 0 ? _a3 : []
      }
    };
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, !result.sexual ? {} : {
    sexual: {
      severity: (_b2 = result.sexual) === null || _b2 === void 0 ? void 0 : _b2["severity"],
      filtered: (_c2 = result.sexual) === null || _c2 === void 0 ? void 0 : _c2["filtered"]
    }
  }), !result.violence ? {} : {
    violence: {
      severity: (_d2 = result.violence) === null || _d2 === void 0 ? void 0 : _d2["severity"],
      filtered: (_e = result.violence) === null || _e === void 0 ? void 0 : _e["filtered"]
    }
  }), !result.hate ? {} : {
    hate: {
      severity: (_f = result.hate) === null || _f === void 0 ? void 0 : _f["severity"],
      filtered: (_g = result.hate) === null || _g === void 0 ? void 0 : _g["filtered"]
    }
  }), !result.self_harm ? {} : {
    selfHarm: {
      severity: (_h = result.self_harm) === null || _h === void 0 ? void 0 : _h["severity"],
      filtered: (_j = result.self_harm) === null || _j === void 0 ? void 0 : _j["filtered"]
    }
  });
}

// node_modules/@azure/core-sse/dist-esm/src/sse.js
function iterateSseStream(chunkIter) {
  return toMessage(toLine(ensureAsyncIterable(chunkIter)));
}
function ensureAsyncIterable(chunkIter) {
  return isReadableStream3(chunkIter) && chunkIter[Symbol.asyncIterator] === void 0 ? toAsyncIterable(chunkIter) : chunkIter;
}
function isReadableStream3(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}
function toAsyncIterable(stream) {
  return __asyncGenerator(this, arguments, function* toAsyncIterable_1() {
    const reader = stream.getReader();
    try {
      while (true) {
        const { value, done } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function concatBuffer(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function createMessage() {
  return {
    data: void 0,
    event: "",
    id: "",
    retry: void 0
  };
}
function toLine(chunkIter) {
  return __asyncGenerator(this, arguments, function* toLine_1() {
    var _a3, e_1, _b2, _c2;
    let buf;
    let bufIdx = 0;
    let fieldLen = -1;
    let discardTrailingNewline = false;
    try {
      for (var _d2 = true, chunkIter_1 = __asyncValues(chunkIter), chunkIter_1_1; chunkIter_1_1 = yield __await(chunkIter_1.next()), _a3 = chunkIter_1_1.done, !_a3; ) {
        _c2 = chunkIter_1_1.value;
        _d2 = false;
        try {
          const chunk = _c2;
          if (buf === void 0) {
            buf = chunk;
            bufIdx = 0;
            fieldLen = -1;
          } else {
            buf = concatBuffer(buf, chunk);
          }
          const bufLen = buf.length;
          let start = 0;
          while (bufIdx < bufLen) {
            if (discardTrailingNewline) {
              if (buf[bufIdx] === 10) {
                start = ++bufIdx;
              }
              discardTrailingNewline = false;
            }
            let end = -1;
            for (; bufIdx < bufLen && end === -1; ++bufIdx) {
              switch (buf[bufIdx]) {
                case 58:
                  if (fieldLen === -1) {
                    fieldLen = bufIdx - start;
                  }
                  break;
                case 13:
                  discardTrailingNewline = true;
                  end = bufIdx;
                  break;
                case 10:
                  end = bufIdx;
                  break;
              }
            }
            if (end === -1) {
              break;
            }
            yield yield __await({ line: buf.subarray(start, end), fieldLen });
            start = bufIdx;
            fieldLen = -1;
          }
          if (start === bufLen) {
            buf = void 0;
          } else if (start !== 0) {
            buf = buf.subarray(start);
            bufIdx -= start;
          }
        } finally {
          _d2 = true;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_d2 && !_a3 && (_b2 = chunkIter_1.return))
          yield __await(_b2.call(chunkIter_1));
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  });
}
function toMessage(lineIter) {
  return __asyncGenerator(this, arguments, function* toMessage_1() {
    var _a3, e_2, _b2, _c2;
    let message = createMessage();
    const decoder = new TextDecoder();
    try {
      for (var _d2 = true, lineIter_1 = __asyncValues(lineIter), lineIter_1_1; lineIter_1_1 = yield __await(lineIter_1.next()), _a3 = lineIter_1_1.done, !_a3; ) {
        _c2 = lineIter_1_1.value;
        _d2 = false;
        try {
          const { line, fieldLen } = _c2;
          if (line.length === 0 && message.data !== void 0) {
            yield yield __await(message);
            message = createMessage();
          } else if (fieldLen > 0) {
            const field = decoder.decode(line.subarray(0, fieldLen));
            const valueOffset = fieldLen + (line[fieldLen + 1] === 32 ? 2 : 1);
            const value = decoder.decode(line.subarray(valueOffset));
            switch (field) {
              case "data":
                message.data = message.data ? message.data + "\n" + value : value;
                break;
              case "event":
                message.event = value;
                break;
              case "id":
                message.id = value;
                break;
              case "retry": {
                const retry = parseInt(value, 10);
                if (!isNaN(retry)) {
                  message.retry = retry;
                }
                break;
              }
            }
          }
        } finally {
          _d2 = true;
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (!_d2 && !_a3 && (_b2 = lineIter_1.return))
          yield __await(_b2.call(lineIter_1));
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  });
}

// node_modules/@azure/openai/dist-esm/src/api/util.js
function wrapError(f, message) {
  try {
    const result = f();
    return result;
  } catch (cause) {
    throw new Error(`${message}: ${cause}`, { cause });
  }
}
function tocamelCase(str) {
  return str.replace(/([_][a-z])/g, (group) => group.toUpperCase().replace("_", ""));
}
function renameKeysToCamelCase(obj) {
  for (const key of Object.keys(obj)) {
    const value = obj[key];
    const newKey = tocamelCase(key);
    if (newKey !== key) {
      delete obj[key];
    }
    obj[newKey] = typeof value === "object" ? Array.isArray(value) ? value.map((v) => renameKeysToCamelCase(v)) : renameKeysToCamelCase(value) : value;
  }
  return obj;
}

// node_modules/@azure/openai/dist-esm/src/api/getSSEs.browser.js
async function getSSEs(response) {
  const iter = await getStream(response);
  return iterateSseStream(iter);
}
async function getStream(response) {
  const { body, status } = await response.asBrowserStream();
  if (status !== "200" && body !== void 0) {
    const text = await streamToText(body);
    throw wrapError(() => JSON.parse(text).error, "Error parsing response body");
  }
  if (!body)
    throw new Error("No stream found in response. Did you enable the stream option?");
  return body;
}
async function streamToText(stream) {
  const reader = stream.getReader();
  const buffers = [];
  let length = 0;
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        return new TextDecoder().decode(concatBuffers(buffers, length));
      }
      length += value.length;
      buffers.push(value);
    }
  } finally {
    reader.releaseLock();
  }
}
function getBuffersLength(buffers) {
  return buffers.reduce((acc, curr) => acc + curr.length, 0);
}
function concatBuffers(buffers, len) {
  const length = len !== null && len !== void 0 ? len : getBuffersLength(buffers);
  const res = new Uint8Array(length);
  for (let i = 0, pos = 0; i < buffers.length; i++) {
    const buffer = buffers[i];
    res.set(buffer, pos);
    pos += buffer.length;
  }
  return res;
}

// node_modules/@azure/openai/dist-esm/src/api/oaiSse.js
function getOaiSSEs(response, toEvent) {
  return __asyncGenerator(this, arguments, function* getOaiSSEs_1() {
    var _a3, e_1, _b2, _c2;
    const stream = yield __await(getSSEs(response));
    let isDone = false;
    try {
      for (var _d2 = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a3 = stream_1_1.done, !_a3; _d2 = true) {
        _c2 = stream_1_1.value;
        _d2 = false;
        const event = _c2;
        if (isDone) {
          continue;
        } else if (event.data === "[DONE]") {
          isDone = true;
        } else {
          yield yield __await(toEvent(wrapError(() => JSON.parse(event.data), "Error parsing an event. See 'cause' for more details")));
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_d2 && !_a3 && (_b2 = stream_1.return))
          yield __await(_b2.call(stream_1));
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  });
}

// node_modules/@azure/openai/dist-esm/src/api/policies/formDataPolicy.browser.js
var formDataPolicyName2 = "formDataWithFileUploadPolicy";
function formDataWithFileUploadPolicy() {
  return {
    name: formDataPolicyName2,
    async sendRequest(request, next) {
      if (request.formData) {
        const formData = request.formData;
        const requestForm = new FormData();
        for (const formKey of Object.keys(formData)) {
          const formValue = formData[formKey];
          if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
              requestForm.append(formKey, subValue);
            }
          } else {
            requestForm.append(formKey, formValue);
          }
        }
        request.body = requestForm;
        request.formData = void 0;
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = new URLSearchParams(requestForm).toString();
        } else if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
          request.headers.delete("Content-Type");
        }
      }
      return next(request);
    }
  };
}
function createFile(data) {
  return new File([data], "placeholder.wav");
}

// node_modules/@azure/openai/dist-esm/src/api/operations.js
function _getEmbeddingsSend(context, input, deploymentId, options = { requestOptions: {} }) {
  return context.path("/deployments/{deploymentId}/embeddings", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: { user: options === null || options === void 0 ? void 0 : options.user, model: options === null || options === void 0 ? void 0 : options.model, input } }));
}
async function _getEmbeddingsDeserialize(result) {
  var _a3;
  if (isUnexpected(result)) {
    throw result.body.error;
  }
  return {
    data: ((_a3 = result.body["data"]) !== null && _a3 !== void 0 ? _a3 : []).map((p) => ({
      embedding: p["embedding"],
      index: p["index"]
    })),
    usage: {
      promptTokens: result.body.usage["prompt_tokens"],
      totalTokens: result.body.usage["total_tokens"]
    }
  };
}
async function getEmbeddings(context, input, deploymentId, options = { requestOptions: {} }) {
  const result = await _getEmbeddingsSend(context, input, deploymentId, options);
  return _getEmbeddingsDeserialize(result);
}
function _getCompletionsSend(context, prompt, deploymentId, options = { requestOptions: {} }) {
  return context.path("/deployments/{deploymentId}/completions", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
    prompt,
    max_tokens: options === null || options === void 0 ? void 0 : options.maxTokens,
    temperature: options === null || options === void 0 ? void 0 : options.temperature,
    top_p: options === null || options === void 0 ? void 0 : options.topP,
    logit_bias: options === null || options === void 0 ? void 0 : options.logitBias,
    user: options === null || options === void 0 ? void 0 : options.user,
    n: options === null || options === void 0 ? void 0 : options.n,
    logprobs: options === null || options === void 0 ? void 0 : options.logprobs,
    echo: options === null || options === void 0 ? void 0 : options.echo,
    stop: options === null || options === void 0 ? void 0 : options.stop,
    presence_penalty: options === null || options === void 0 ? void 0 : options.presencePenalty,
    frequency_penalty: options === null || options === void 0 ? void 0 : options.frequencyPenalty,
    best_of: options === null || options === void 0 ? void 0 : options.bestOf,
    stream: options === null || options === void 0 ? void 0 : options.stream,
    model: options === null || options === void 0 ? void 0 : options.model
  } }));
}
async function _getCompletionsDeserialize(result) {
  var _a3, _b2;
  if (isUnexpected(result)) {
    throw result.body.error;
  }
  return {
    id: result.body["id"],
    created: new Date(result.body["created"]),
    promptFilterResults: ((_a3 = result.body["prompt_annotations"]) !== null && _a3 !== void 0 ? _a3 : []).map((p) => {
      var _a4, _b3, _c2, _d2, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
      return {
        promptIndex: p["prompt_index"],
        contentFilterResults: !p.content_filter_results ? void 0 : {
          sexual: !((_a4 = p.content_filter_results) === null || _a4 === void 0 ? void 0 : _a4.sexual) ? void 0 : {
            severity: (_c2 = (_b3 = p.content_filter_results) === null || _b3 === void 0 ? void 0 : _b3.sexual) === null || _c2 === void 0 ? void 0 : _c2["severity"],
            filtered: (_e = (_d2 = p.content_filter_results) === null || _d2 === void 0 ? void 0 : _d2.sexual) === null || _e === void 0 ? void 0 : _e["filtered"]
          },
          violence: !((_f = p.content_filter_results) === null || _f === void 0 ? void 0 : _f.violence) ? void 0 : {
            severity: (_h = (_g = p.content_filter_results) === null || _g === void 0 ? void 0 : _g.violence) === null || _h === void 0 ? void 0 : _h["severity"],
            filtered: (_k = (_j = p.content_filter_results) === null || _j === void 0 ? void 0 : _j.violence) === null || _k === void 0 ? void 0 : _k["filtered"]
          },
          hate: !((_l = p.content_filter_results) === null || _l === void 0 ? void 0 : _l.hate) ? void 0 : {
            severity: (_o = (_m = p.content_filter_results) === null || _m === void 0 ? void 0 : _m.hate) === null || _o === void 0 ? void 0 : _o["severity"],
            filtered: (_q = (_p = p.content_filter_results) === null || _p === void 0 ? void 0 : _p.hate) === null || _q === void 0 ? void 0 : _q["filtered"]
          },
          selfHarm: !((_r = p.content_filter_results) === null || _r === void 0 ? void 0 : _r.self_harm) ? void 0 : {
            severity: (_t = (_s = p.content_filter_results) === null || _s === void 0 ? void 0 : _s.self_harm) === null || _t === void 0 ? void 0 : _t["severity"],
            filtered: (_v = (_u = p.content_filter_results) === null || _u === void 0 ? void 0 : _u.self_harm) === null || _v === void 0 ? void 0 : _v["filtered"]
          }
        }
      };
    }),
    choices: ((_b2 = result.body["choices"]) !== null && _b2 !== void 0 ? _b2 : []).map((p) => {
      var _a4, _b3, _c2, _d2, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
      return {
        text: p["text"],
        index: p["index"],
        contentFilterResults: !p.content_filter_results ? void 0 : {
          sexual: !((_a4 = p.content_filter_results) === null || _a4 === void 0 ? void 0 : _a4.sexual) ? void 0 : {
            severity: (_c2 = (_b3 = p.content_filter_results) === null || _b3 === void 0 ? void 0 : _b3.sexual) === null || _c2 === void 0 ? void 0 : _c2["severity"],
            filtered: (_e = (_d2 = p.content_filter_results) === null || _d2 === void 0 ? void 0 : _d2.sexual) === null || _e === void 0 ? void 0 : _e["filtered"]
          },
          violence: !((_f = p.content_filter_results) === null || _f === void 0 ? void 0 : _f.violence) ? void 0 : {
            severity: (_h = (_g = p.content_filter_results) === null || _g === void 0 ? void 0 : _g.violence) === null || _h === void 0 ? void 0 : _h["severity"],
            filtered: (_k = (_j = p.content_filter_results) === null || _j === void 0 ? void 0 : _j.violence) === null || _k === void 0 ? void 0 : _k["filtered"]
          },
          hate: !((_l = p.content_filter_results) === null || _l === void 0 ? void 0 : _l.hate) ? void 0 : {
            severity: (_o = (_m = p.content_filter_results) === null || _m === void 0 ? void 0 : _m.hate) === null || _o === void 0 ? void 0 : _o["severity"],
            filtered: (_q = (_p = p.content_filter_results) === null || _p === void 0 ? void 0 : _p.hate) === null || _q === void 0 ? void 0 : _q["filtered"]
          },
          selfHarm: !((_r = p.content_filter_results) === null || _r === void 0 ? void 0 : _r.self_harm) ? void 0 : {
            severity: (_t = (_s = p.content_filter_results) === null || _s === void 0 ? void 0 : _s.self_harm) === null || _t === void 0 ? void 0 : _t["severity"],
            filtered: (_v = (_u = p.content_filter_results) === null || _u === void 0 ? void 0 : _u.self_harm) === null || _v === void 0 ? void 0 : _v["filtered"]
          }
        },
        logprobs: p.logprobs === null ? null : {
          tokens: p.logprobs["tokens"],
          tokenLogprobs: p.logprobs["token_logprobs"],
          topLogprobs: p.logprobs["top_logprobs"],
          textOffset: p.logprobs["text_offset"]
        },
        finishReason: p["finish_reason"]
      };
    }),
    usage: {
      completionTokens: result.body.usage["completion_tokens"],
      promptTokens: result.body.usage["prompt_tokens"],
      totalTokens: result.body.usage["total_tokens"]
    }
  };
}
async function getCompletions(context, prompt, deploymentId, options = { requestOptions: {} }) {
  const result = await _getCompletionsSend(context, prompt, deploymentId, options);
  return _getCompletionsDeserialize(result);
}
function _getChatCompletionsSend(context, messages, deploymentId, options = { requestOptions: {} }) {
  return context.path("/deployments/{deploymentId}/chat/completions", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
    messages: parseChatMessage(messages),
    functions: options === null || options === void 0 ? void 0 : options.functions,
    function_call: options === null || options === void 0 ? void 0 : options.functionCall,
    max_tokens: options === null || options === void 0 ? void 0 : options.maxTokens,
    temperature: options === null || options === void 0 ? void 0 : options.temperature,
    top_p: options === null || options === void 0 ? void 0 : options.topP,
    logit_bias: options === null || options === void 0 ? void 0 : options.logitBias,
    user: options === null || options === void 0 ? void 0 : options.user,
    n: options === null || options === void 0 ? void 0 : options.n,
    stop: options === null || options === void 0 ? void 0 : options.stop,
    presence_penalty: options === null || options === void 0 ? void 0 : options.presencePenalty,
    frequency_penalty: options === null || options === void 0 ? void 0 : options.frequencyPenalty,
    stream: options === null || options === void 0 ? void 0 : options.stream,
    model: options === null || options === void 0 ? void 0 : options.model,
    dataSources: options === null || options === void 0 ? void 0 : options.dataSources
  } }));
}
function _getChatCompletionsWithAzureExtensionsSend(context, messages, deploymentId, options = { requestOptions: {} }) {
  return context.path("/deployments/{deploymentId}/extensions/chat/completions", deploymentId).post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
    messages: parseChatMessage(messages),
    functions: options === null || options === void 0 ? void 0 : options.functions,
    function_call: options === null || options === void 0 ? void 0 : options.functionCall,
    max_tokens: options === null || options === void 0 ? void 0 : options.maxTokens,
    temperature: options === null || options === void 0 ? void 0 : options.temperature,
    top_p: options === null || options === void 0 ? void 0 : options.topP,
    logit_bias: options === null || options === void 0 ? void 0 : options.logitBias,
    user: options === null || options === void 0 ? void 0 : options.user,
    n: options === null || options === void 0 ? void 0 : options.n,
    stop: options === null || options === void 0 ? void 0 : options.stop,
    presence_penalty: options === null || options === void 0 ? void 0 : options.presencePenalty,
    frequency_penalty: options === null || options === void 0 ? void 0 : options.frequencyPenalty,
    stream: options === null || options === void 0 ? void 0 : options.stream,
    model: options === null || options === void 0 ? void 0 : options.model,
    dataSources: options === null || options === void 0 ? void 0 : options.dataSources
  } }));
}
function _beginAzureBatchImageGenerationSend(context, prompt, options = { requestOptions: {} }) {
  return context.path("/images/generations:submit").post(Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
    prompt,
    n: options === null || options === void 0 ? void 0 : options.n,
    size: options === null || options === void 0 ? void 0 : options.size,
    response_format: options === null || options === void 0 ? void 0 : options.responseFormat,
    user: options === null || options === void 0 ? void 0 : options.user
  } }));
}
function listCompletions(context, prompt, deploymentName, options = { requestOptions: {} }) {
  const response = _getCompletionsSend(context, prompt, deploymentName, Object.assign(Object.assign({}, options), { stream: true }));
  return getOaiSSEs(response, getCompletionsResult);
}
async function getImages(context, prompt, options = { requestOptions: {} }) {
  const response = await _beginAzureBatchImageGenerationSend(context, prompt, options);
  if (isUnexpected(response)) {
    const body = response.body;
    if (body.created && body.data) {
      return body;
    }
    throw response.body.error;
  }
  if (response.status === "202") {
    const poller = await getLongRunningPoller(context, response);
    const result = await poller.pollUntilDone();
    return getImageResultsDeserialize(result);
  } else {
    return getImageResultsDeserialize(response);
  }
}
function listChatCompletions(context, messages, deploymentName, options = { requestOptions: {} }) {
  const response = _getChatCompletionsSendX(context, messages, deploymentName, Object.assign(Object.assign({}, options), { stream: true }));
  return getOaiSSEs(response, getChatCompletionsResult);
}
async function getChatCompletions(context, messages, deploymentId, options = { requestOptions: {} }) {
  const result = await _getChatCompletionsSendX(context, messages, deploymentId, options);
  if (isUnexpected(result)) {
    throw result.body.error;
  }
  return getChatCompletionsResult(result.body);
}
function convertResultTypes({ created, data }) {
  if (typeof data[0].url === "string") {
    return {
      created: new Date(created),
      data
    };
  } else {
    return {
      created: new Date(created),
      data: data.map((item) => {
        return {
          base64Data: item.b64_json
        };
      })
    };
  }
}
function getImageResultsDeserialize(response) {
  if (isUnexpected(response) || !response.body.result) {
    throw response.body.error;
  }
  const result = response.body.result;
  return convertResultTypes(result);
}
function _getChatCompletionsSendX(context, messages, deploymentName, options = { requestOptions: {} }) {
  var _a3, _b2;
  return ((_a3 = options.azureExtensionOptions) === null || _a3 === void 0 ? void 0 : _a3.extensions) ? _getChatCompletionsWithAzureExtensionsSend(context, messages, deploymentName, Object.assign(Object.assign({}, options), { dataSources: (_b2 = options.azureExtensionOptions) === null || _b2 === void 0 ? void 0 : _b2.extensions })) : _getChatCompletionsSend(context, messages, deploymentName, options);
}
async function getAudioTranslation(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
  const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};
  const response_format = typeof formatOrOptions === "string" ? formatOrOptions : void 0;
  const { temperature, prompt, model } = options, rest = __rest(options, ["temperature", "prompt", "model"]);
  const { body, status } = await context.pathUnchecked("deployments/{deploymentId}/audio/translations", deploymentName).post(Object.assign(Object.assign({ body: Object.assign(Object.assign(Object.assign(Object.assign({ file: await createFile(fileContent) }, response_format && { response_format }), temperature !== void 0 ? { temperature } : {}), prompt && { prompt }), model && { model }) }, rest), { contentType: "multipart/form-data" }));
  if (status !== "200") {
    throw body.error;
  }
  return response_format !== "verbose_json" ? body : renameKeysToCamelCase(body);
}
async function getAudioTranscription(context, deploymentName, fileContent, formatOrOptions, inputOptions) {
  const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};
  const response_format = typeof formatOrOptions === "string" ? formatOrOptions : void 0;
  const { temperature, language, prompt, model } = options, rest = __rest(options, ["temperature", "language", "prompt", "model"]);
  const { body, status } = await context.pathUnchecked("deployments/{deploymentId}/audio/transcriptions", deploymentName).post(Object.assign(Object.assign({ body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ file: await createFile(fileContent) }, response_format && { response_format }), language && { language }), temperature !== void 0 ? { temperature } : {}), prompt && { prompt }), model && { model }) }, rest), { contentType: "multipart/form-data" }));
  if (status !== "200") {
    throw body.error;
  }
  return response_format !== "verbose_json" ? body : renameKeysToCamelCase(body);
}
function parseChatMessage(messages) {
  return messages.map((p) => {
    var _a3;
    return {
      role: p.role,
      content: (_a3 = p.content) !== null && _a3 !== void 0 ? _a3 : null,
      name: p.name,
      function_call: p.functionCall,
      context: p.context
    };
  });
}

// node_modules/@azure/openai/dist-esm/src/api/policies/nonAzure.js
function nonAzurePolicy() {
  const policy = {
    name: "openAiEndpoint",
    sendRequest: (request, next) => {
      const obj = new URL(request.url);
      const parts = obj.pathname.split("/");
      switch (parts[parts.length - 1]) {
        case "completions":
          if (parts[parts.length - 2] === "chat") {
            obj.pathname = `${parts[1]}/chat/completions`;
          } else {
            obj.pathname = `${parts[1]}/completions`;
          }
          break;
        case "embeddings":
          obj.pathname = `${parts[1]}/embeddings`;
          break;
        case "generations:submit":
          obj.pathname = `${parts[1]}/images/generations`;
          break;
        case "transcriptions":
          obj.pathname = `${parts[1]}/audio/transcriptions`;
          break;
        case "translations":
          obj.pathname = `${parts[1]}/audio/translations`;
          break;
      }
      obj.searchParams.delete("api-version");
      request.url = obj.toString();
      return next(request);
    }
  };
  return policy;
}

// node_modules/@azure/openai/dist-esm/src/OpenAIClient.js
var OpenAIClient = class {
  constructor(endpointOrOpenAiKey, credOrOptions = {}, options = {}) {
    var _a3, _b2;
    this._isAzure = false;
    let opts;
    let endpoint;
    let cred;
    if (isCred(credOrOptions)) {
      endpoint = endpointOrOpenAiKey;
      cred = credOrOptions;
      opts = options;
      this._isAzure = true;
    } else {
      endpoint = createOpenAIEndpoint(1);
      cred = endpointOrOpenAiKey;
      const { credentials } = credOrOptions, restOpts = __rest(credOrOptions, ["credentials"]);
      opts = Object.assign({ credentials: {
        apiKeyHeaderName: (_a3 = credentials === null || credentials === void 0 ? void 0 : credentials.apiKeyHeaderName) !== null && _a3 !== void 0 ? _a3 : "Authorization",
        scopes: credentials === null || credentials === void 0 ? void 0 : credentials.scopes
      } }, restOpts);
    }
    this._client = createOpenAI(endpoint, cred, Object.assign(Object.assign({}, opts), this._isAzure ? {} : {
      additionalPolicies: [
        ...(_b2 = opts.additionalPolicies) !== null && _b2 !== void 0 ? _b2 : [],
        {
          position: "perCall",
          policy: nonAzurePolicy()
        }
      ]
    }));
    this._client.pipeline.removePolicy({ name: formDataPolicyName });
    this._client.pipeline.addPolicy(formDataWithFileUploadPolicy());
  }
  /**
   * Returns textual completions as configured for a given prompt.
   * @param deploymentName - Specifies either the model deployment name (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param prompt - The prompt to use for this request.
   * @param options - The options for this completions request.
   * @returns The completions for the given prompt.
   */
  getCompletions(deploymentName, prompt, options = { requestOptions: {} }) {
    this.setModel(deploymentName, options);
    return getCompletions(this._client, prompt, deploymentName, options);
  }
  /**
   * Lists the completions tokens as they become available for a given prompt.
   * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param prompt - The prompt to use for this request.
   * @param options - The completions options for this completions request.
   * @returns An asynchronous iterable of completions tokens.
   */
  listCompletions(deploymentName, prompt, options = {}) {
    this.setModel(deploymentName, options);
    return listCompletions(this._client, prompt, deploymentName, options);
  }
  /**
   * Return the computed embeddings for a given prompt.
   * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param input - The prompt to use for this request.
   * @param options - The embeddings options for this embeddings request.
   * @returns The embeddings for the given prompt.
   */
  getEmbeddings(deploymentName, input, options = { requestOptions: {} }) {
    this.setModel(deploymentName, options);
    return getEmbeddings(this._client, input, deploymentName, options);
  }
  /**
   * Get chat completions for provided chat context messages.
   * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param messages - The chat context messages to use for this request.
   * @param options - The chat completions options for this completions request.
   * @returns The chat completions for the given chat context messages.
   */
  getChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
    this.setModel(deploymentName, options);
    return getChatCompletions(this._client, messages, deploymentName, options);
  }
  /**
   * Lists the chat completions tokens as they become available for a chat context.
   * @param deploymentName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param messages - The chat context messages to use for this request.
   * @param options - The chat completions options for this chat completions request.
   * @returns An asynchronous iterable of chat completions tokens.
   */
  listChatCompletions(deploymentName, messages, options = { requestOptions: {} }) {
    this.setModel(deploymentName, options);
    return listChatCompletions(this._client, messages, deploymentName, options);
  }
  /**
   * Starts the generation of a batch of images from a text caption
   * @param prompt - The prompt to use for this request.
   * @param options - The options for this image request.
   * @returns The image generation response (containing url or base64 data).
   */
  getImages(prompt, options = { requestOptions: {} }) {
    return getImages(this._client, prompt, options);
  }
  // implementation
  async getAudioTranscription(deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : void 0;
    this.setModel(deploymentName, options);
    if (response_format === void 0) {
      return getAudioTranscription(this._client, deploymentName, fileContent, options);
    }
    return getAudioTranscription(this._client, deploymentName, fileContent, response_format, options);
  }
  // implementation
  async getAudioTranslation(deploymentName, fileContent, formatOrOptions, inputOptions) {
    const options = inputOptions !== null && inputOptions !== void 0 ? inputOptions : typeof formatOrOptions === "string" ? {} : formatOrOptions !== null && formatOrOptions !== void 0 ? formatOrOptions : {};
    const response_format = typeof formatOrOptions === "string" ? formatOrOptions : void 0;
    this.setModel(deploymentName, options);
    if (response_format === void 0) {
      return getAudioTranslation(this._client, deploymentName, fileContent, options);
    }
    return getAudioTranslation(this._client, deploymentName, fileContent, response_format, options);
  }
  setModel(model, options) {
    if (!this._isAzure) {
      options.model = model;
    }
  }
};
function createOpenAIEndpoint(version) {
  return `https://api.openai.com/v${version}`;
}
function isCred(cred) {
  return isTokenCredential(cred) || cred.key !== void 0;
}
export {
  AzureKeyCredential,
  OpenAIClient,
  OpenAIKeyCredential
};
//# sourceMappingURL=@azure_openai.js.map
